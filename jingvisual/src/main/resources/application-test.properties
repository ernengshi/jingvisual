#http://blog.didispace.com/springbootproperties/
#测试环境
#    application.properties中配置通用内容，并设置spring.profiles.active=dev，以开发环境为默认配置
#    application-{profile}.properties中配置各个环境不同的内容
#    通过命令行方式去激活不同环境的配置

#server.port=8088

#tomcat http://blog.csdn.net/u012702547/article/details/53790722 https://zuimeidaima.com/2016/11/04/spring%20boot%20%E9%85%8D%E7%BD%AEhttps%7Cssl/
#keytool -genkey -alias tomcat  -storetype PKCS12 -keyalg RSA -keysize 2048  -keystore keystore.p12 -validity 3650
jingvisual.http.port = 80
server.port = 8089
server.ssl.key-store = classpath:keystore.p12
server.ssl.key-store-password = jingcloud
#server.ssl.key-password = cloud
server.ssl.key-store-type: PKCS12
server.ssl.key-alias: tomcat

#treadpool
thread-pool.task-scheduler.thread-name-prefix=jingvisual-cheduler-
thread-pool.task-scheduler.pool-size=5

Thread-pool-task-executor.thread-name-prefix=jingvisual-async-
Thread-pool-task-executor.core-pool-size=5
Thread-pool-task-executor.max-pool-size=10
Thread-pool-task-executor.queue-capacity=10

#JdbcTemplate 要是有多数据源则不能有默认的
#Spring的JdbcTemplate是自动配置的，你可以直接使用@Autowired来注入到你自己的bean中来使用

#spring.datasource.url=jdbc:mysql://192.168.20.254:3306/test
#spring.datasource.username=cloud
#spring.datasource.password=cloud
#spring.datasource.driver-class-name=com.mysql.jdbc.Driver

#连接JNDI数据源
#spring.datasource.jndi-name=java:jboss/datasources/customers



#自动创建表结构的设置

#create：每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。
#create-drop：每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。
#update：最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等应用第一次运行起来后才会。
#validate：每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值
spring.jpa.properties.hibernate.hbm2ddl.auto=update
#开启hibernate对sql语句的打印
spring.jpa.properties.hibernate.show_sql=true

#多数据源配置
#数据源1
spring.datasource.primary.url=jdbc:mysql://192.168.20.254:3306/test?useUnicode=true&characterEncoding=utf-8
spring.datasource.primary.username=cloud
spring.datasource.primary.password=cloud
spring.datasource.primary.driver-class-name=com.mysql.jdbc.Driver
#连接池配置
#指定连接池最大的空闲连接数量
spring.datasource.primary.max-idle=10
#指定连接池等待连接返回的最大等待时间，毫秒单位.
spring.datasource.primary.max-wait=10000
#指定必须保持连接的最小值(For DBCP and Tomcat connection pools)
spring.datasource.primary.min-idle=5
#指定启动连接池时，初始建立的连接数量
spring.datasource.primary.initial-size=5
#指定获取连接时连接校验的sql查询语句.
spring.datasource.primary.validation-query=SELECT 1
#获取连接时候验证，会影响性能
spring.datasource.primary.test-on-borrow=false
#验证连接的有效性
spring.datasource.primary.test-while-idle=true
#空闲连接回收的时间间隔，与test-while-idle一起使用，设置5分钟
spring.datasource.primary.time-between-eviction-runs-millis=300000
#连接池空闲连接的有效时间 ，设置30分钟
spring.datasource.primary.min-evictable-idle-time-millis=1800000
#连接池配置中的timeBetweenEvictionRunsMillis和minEvictableIdleTimeMillis的时间小于或者等于mysql数据库中wait_timeout的时间。


#数据源2
spring.datasource.secondary.url=jdbc:mysql://192.168.20.254:3306/cloud?useUnicode=true&characterEncoding=utf-8
spring.datasource.secondary.username=cloud
spring.datasource.secondary.password=cloud
spring.datasource.secondary.driver-class-name=com.mysql.jdbc.Driver
#连接池配置
#指定连接池最大的空闲连接数量
spring.datasource.secondary.max-idle=10
#指定连接池等待连接返回的最大等待时间，毫秒单位.
spring.datasource.secondary.max-wait=10000
#指定必须保持连接的最小值(For DBCP and Tomcat connection pools)
spring.datasource.secondary.min-idle=5
#指定启动连接池时，初始建立的连接数量
spring.datasource.secondary.initial-size=5
#指定获取连接时连接校验的sql查询语句.
spring.datasource.secondary.validation-query=SELECT 1
#获取连接时候验证，会影响性能
spring.datasource.secondary.test-on-borrow=false
#验证连接的有效性
spring.datasource.secondary.test-while-idle=true
#空闲连接回收的时间间隔，与test-while-idle一起使用，设置5分钟
spring.datasource.secondary.time-between-eviction-runs-millis=300000
#连接池空闲连接的有效时间 ，设置30分钟
spring.datasource.secondary.min-evictable-idle-time-millis=1800000


#nosql redis  

# REDIS (RedisProperties)
# Redis数据库索引（默认为0）
spring.redis.database=0
# Redis服务器地址
spring.redis.host=192.168.20.254
# Redis服务器连接端口
spring.redis.port=6379
# Redis服务器连接密码（默认为空）
spring.redis.password=
# 连接池最大连接数（使用负值表示没有限制）
spring.redis.pool.max-active=8
# 连接池最大阻塞等待时间（使用负值表示没有限制）
spring.redis.pool.max-wait=-1
# 连接池中的最大空闲连接
spring.redis.pool.max-idle=8
# 连接池中的最小空闲连接
spring.redis.pool.min-idle=0
# 连接超时时间（毫秒）
spring.redis.timeout=0

#spring.cache.type=ehcache
#spring.cache.type=redis

#log
#控制台输出
#该属性置为true的时候，核心Logger（包含嵌入式容器、hibernate、spring）会输出更多内容，但是你自己应用的日志并不会输出为DEBUG级别。

#debug=true
#日志多彩输出
#    NEVER：禁用ANSI-colored输出（默认项）
#    DETECT：会检查终端是否支持ANSI，是的话就采用彩色输出（推荐项）
#    ALWAYS：总是使用ANSI-colored格式输出，若终端不支持的时候，会有很多干扰信息，不推荐使用

spring.output.ansi.enabled=ALWAYS
#文件输出
#若要增加文件输出，需要在application.properties中配置logging.file或logging.path属性。
#
#    logging.file，设置文件，可以是绝对路径，也可以是相对路径。如：logging.file=my.log
#    logging.path，设置目录，会在该目录下创建spring.log文件，并写入日志内容，如：logging.path=/var/log

#logging.file=C:\\Users\\ly\\Desktop\\aa\\test.log
#级别控制
#Spring Boot在所有内部日志中使用Commons Logging，但是默认配置也提供了对常用日志的支持，如：Java Util Logging，Log4J, Log4J2和Logback。每种Logger都可以通过配置使用控制台或者文件输出日志内容。
#在Spring Boot中只需要在application.properties中进行配置完成日志记录的级别控制。
#配置格式：logging.level.*=LEVEL
#
#    logging.level：日志级别控制前缀，*为包名或Logger名
#    LEVEL：选项TRACE, DEBUG, INFO, WARN, ERROR, FATAL, OFF

#logging.level.cn.com.jingcloud=DEBUG

